// Class automatically generated by Dev-C++ New Class wizard
#ifndef OFMYVIS_H
#define OFMYVIS_H
//#include <GL/gl.h>
//#include <GL/glut.h>
#include <GL/glu.h> //Cesar 2006-11-01 ->Esse faz parte do meu
#include<stdio.h>
#include<iostream>
//#include <stdlib.h>
#include "ofMyTraits.h"
#include "ofVerticesIterator.h"
#include "ofCellsIterator.h"
#include "ofRuppert2D.h"
#include "ofRemesh.h"
#include "ofMyOffReader.h"
#include "ofPolyWriter.h"
#include "ofVtkWriter.h"
#include "ofVector.h"
#define INIT_VIEW_X	 0.0
#define INIT_VIEW_Y  0.0
#define INIT_VIEW_Z  5.0
#define VIEW_LEFT	-3.0
#define VIEW_RIGHT	 3.0
#define VIEW_BOTTOM	-3.0
#define VIEW_TOP	 3.0
#define VIEW_NEAR	 0.000000001
#define VIEW_FAR	 200000.0
/*
 * No description
 */
namespace of
{
#define SPACE5 typename ofMyVisParameters<_Traits, _Traits3D>::space

template <class _Traits,class _Traits3D> class ofMyVisParameters
{
      public:

		typedef typename _Traits::sMesh sMesh;
		typedef typename _Traits::space space;
		typedef typename _Traits::sVertex sVertex;
		typedef typename _Traits::ids ids;
		typedef typename _Traits::sCell sCell;
		typedef typename _Traits::sEdge sEdge;
        float angleX ,vX,vY,vZ;
		float mX,mY,mZ;
		float mtX,mtY,mtZ;
		float rX,rY;
		float rtX,rtY;
		float cx,cy;
        int mousex,mousey;
        int sizex,sizey,cont,mode;
        int thisWidth,thisHeight;
        char filen[200];
        GLUquadricObj * object;
        sMesh  *malha;
		sMesh *malha2;
		sMesh *malha3;
		sVertex *v;
		sCell *c;
        double pmaxY,pminY;
        int dim;
        bool axok;
        bool gridok;
		bool edgeok;
		bool cellok;
        float fv;
        float defaultz;
		bool step;
		bool executed;
		bool boundary_inserted;
		bool iok;
		bool remeshok;
		float fact;
		ofRuppert2D<_Traits> ruppert;
		ofRemesh<_Traits,_Traits3D> remesh;
		ofMyOffReader<_Traits> reader;
		ofTetGenReader<_Traits> Tetreader;
		ofPolyWriter<_Traits> saida;
		//ofMeshWriter<_Traits> mwriter;
		ofVtkWriter<_Traits> vtkwriter;
		sEdge e1;
		sCell *pc;
		ofVector<ids,ids> *ref;
};

extern ofMyVisParameters<MyofDefault2D,MyofDefault3D> Par;
template <class _Traits> class ofMyVis
{
	public:
	typedef typename _Traits::sMesh sMesh;
	typedef typename _Traits::space space;
	typedef typename _Traits::sVertex sVertex;
	typedef typename _Traits::ids ids;
	typedef typename _Traits::sCell sCell;
	typedef typename _Traits::sEdge sEdge;
		// class constructor
		ofMyVis();
		ofMyVis(sMesh *_mesh,int d);
		ofMyVis(char* filename,int d);
		// class destructor
		~ofMyVis();



		void run(bool ok=true);



		private:

        double maxY;
        double minY;

		sMesh *malha;
		ofList<ids> *skiny_cells;





static void resize(int width, int height)
{
/* Save the new width and height */
   double varx,vary;
    GLfloat fv;
   if(Par.dim==2)
   {
     varx=(Par.malha->getMaxX()-Par.malha->getMinX());
   vary=Par.malha->getMaxY()-Par.malha->getMinY();
      if(varx>vary)
         fv=varx*5.0;
      else
        fv=vary*5.0;
   }

   Par.fv=fv;
   Par.thisWidth = width;
   Par.thisHeight = height;

   GLfloat Ratio;
	if(height!=0.0)
	   Ratio = width/height;
	else
		Ratio=1.0;
   /* Reset the viewport... */
   glViewport(0, 0, width, height);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   int intfv=(int)fv;
   if (intfv>100.0)
		fv=100.0;
	//!background color
      glClearColor (0.0, 0.0, 0.0, 1.0);
    gluPerspective(fv, Ratio, VIEW_NEAR, VIEW_FAR);
   glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
	  glPushMatrix();
	 glTranslatef(INIT_VIEW_X, INIT_VIEW_Y, INIT_VIEW_Z );
	  glPopMatrix();
   // change the viewing position and orientation

   gluLookAt(
      Par.vX, Par.vY, Par.vZ,         // eye location
      0.0,0.0, 0.0,      // center location
      0.0, 1.0, 0.0);   // up vector
   }
static void printMode()
{
     switch (Par.mode) {
   case 0   :   printf("Reset - Initial \n"); break;
   case 1   :   printf("Tranlate X Y \n"); break;
   case 2   :   printf("Rotate X Y\n"); break;
   case 3   :   printf("Zoom Z\n");
   }
 }
static void Display_mesh2()
{

	double x,y,z,x1,y1,z1;
	glPushMatrix();  // transform for all objects


	int j;
	ofVerticesIterator<_Traits> iv(Par.malha2);
	ofCellsIterator<_Traits> ic(Par.malha2);
	glColor3f (1.0, 0.0, 0.0);
	glBegin(GL_POINTS);
	glPointSize(5.0f);
	bool cok=true;
	for(iv.initialize(); iv.notFinish(); ++iv)
	{



		glVertex3f(iv->getCoord(0),iv->getCoord(1),iv->getCoord(2));
		cok=!cok;
	}
	glPointSize(4.0f);
	glEnd();
	glColor3f (1.0, 0.0, 0.0);
	glBegin(GL_LINES);
	for(ic.initialize(); ic.notFinish(); ++ic)
	{
		for(j=0;j<3;j++)
		{
			x=Par.malha2->getVertex(ic->getVertexId(j))->getCoord(0);
			y=Par.malha2->getVertex(ic->getVertexId(j))->getCoord(1);
			z=Par.malha2->getVertex(ic->getVertexId(j))->getCoord(2);
			glVertex3f(x,y,z);
			x1=Par.malha2->getVertex(ic->getVertexId((j+1)%3))->getCoord(0);
			y1=Par.malha2->getVertex(ic->getVertexId((j+1)%3))->getCoord(1);
			z1=Par.malha2->getVertex(ic->getVertexId((j+1)%3))->getCoord(2);
			glVertex3f(x1,y1,z1);
		}

	}
	glEnd();
}
static void quit(int key)
{
#ifdef GLUT
     if (key == GLUT_KEY_END)
#endif
	   exit(1);
}
   static void display()
   {
        double x,y,z,x1,y1,z1;

        int ino,inc,j;


   glClear (GL_COLOR_BUFFER_BIT);
   glPointSize(4.0f);
   GLfloat cx;
   GLfloat cy,rx,ry,rz,rox,roy,roz;
   if(Par.executed)
   {
	   ofVerticesIterator<_Traits> it(Par.malha);
		ofCellsIterator<_Traits> ic(Par.malha);
        int np=Par.malha->getNumberOfVertices();
		int nc=Par.malha->getNumberOfCells();
	if(Par.dim==2)
	{
	cx = (Par.malha->getMaxX()+Par.malha->getMinX())*0.5;
	//cx=.0;
	cy = (Par.malha->getMaxY()+Par.malha->getMinY())*0.5;
	Par.cx=cx;
	Par.cy=cy;
	//mX=-cx+mX;
	//mY=-cy+mY;

		glPushMatrix();  // transform for all objects
		glRotatef(Par.rX, 0, 1, 0);   // degrees, x, y, z
		glRotatef(Par.rY, 1, 0, 0);
		glTranslatef(Par.mX-cx, Par.mY-cy, Par.mZ);
		//glPopMatrix();
		glColor3f (0.0, 0.0, 0.0);
		glBegin(GL_POINTS);
		it.initialize();
		//++it;++it;++it;++it;
		np;
		for(ino=0;ino<np;ino++)
		{
			x=it->getCoord(0);
			y=it->getCoord(1);

			glVertex3f(x,y,it->getCoord(2));
			++it;
		}
		glEnd();
		glLineWidth(1.0);
		glBegin(GL_LINES);

		ic.initialize();
		if(Par.ruppert.getNumberOfViolatedEdges()>0)
		{
			rox=0.5;roy=0.5;roz=0.5;


		}
		else
		{
			rox=0.0;roy=1.0;roz=0.0;
		}
		for(inc=0;inc<nc;inc++)
		{
			if((!Par.remeshok)&&(Par.ruppert.isBadCell(&ic)))
			{
					rx=1.0; ry=0.0; rz=0.0;
			}
				else
				{
					rx=rox; ry=roy; rz=roz;
				}


			for(j=0;j<3;j++)
			{
				if((!Par.remeshok)&&(Par.ruppert.isRestrictionEdge(ic->getVertexId(j),ic->getVertexId((j+1)%3))))
					glColor3f (0.0, 0.0, 1.0);
				else
					glColor3f (rx, ry, rz);

			x=Par.malha->getVertex(ic->getVertexId(j))->getCoord(0);
			y=Par.malha->getVertex(ic->getVertexId(j))->getCoord(1);
			z=Par.malha->getVertex(ic->getVertexId(j))->getCoord(2);
			glVertex3f(x,y,z);
			x1=Par.malha->getVertex(ic->getVertexId((j+1)%3))->getCoord(0);
			y1=Par.malha->getVertex(ic->getVertexId((j+1)%3))->getCoord(1);
			z1=Par.malha->getVertex(ic->getVertexId((j+1)%3))->getCoord(2);
			glVertex3f(x1,y1,z1);
			}
			++ic;
		}
		glEnd();

		if((!Par.remeshok)&&(Par.ruppert.getNumberOfViolatedEdges()>0))
		{
			glLineWidth(4.0);
			glBegin(GL_LINES);
			Par.e1=Par.ruppert.getFirstViolatedEdge();
			glColor3f(1.0,0.0,0.0);
			x=Par.malha->getVertex(Par.e1.first)->getCoord(0);
			y=Par.malha->getVertex(Par.e1.first)->getCoord(1);
			z=Par.malha->getVertex(Par.e1.first)->getCoord(2);
			glVertex3f(x,y,z);
			x1=Par.malha->getVertex(Par.e1.second)->getCoord(0);
			y1=Par.malha->getVertex(Par.e1.second)->getCoord(1);
			z1=Par.malha->getVertex(Par.e1.second)->getCoord(2);
			glVertex3f(x1,y1,z1);
			glEnd();

		}

		if((!Par.remeshok)&&(Par.ruppert.getNumberofSkynnyCells()>0))
		{
			glLineWidth(3.0);
			Par.pc=Par.malha->getCell(Par.ruppert.getFirstSkinnyCell());
			glColor3f(1.0,1.0,0.0);
			glBegin(GL_LINES);
			for(j=0;j<3;j++)
			{


			x=Par.malha->getVertex(Par.pc->getVertexId(j))->getCoord(0);
			y=Par.malha->getVertex(Par.pc->getVertexId(j))->getCoord(1);
			z=Par.malha->getVertex(Par.pc->getVertexId(j))->getCoord(2);
			glVertex3f(x,y,z);
			x1=Par.malha->getVertex(Par.pc->getVertexId((j+1)%3))->getCoord(0);
			y1=Par.malha->getVertex(Par.pc->getVertexId((j+1)%3))->getCoord(1);
			z1=Par.malha->getVertex(Par.pc->getVertexId((j+1)%3))->getCoord(2);
			glVertex3f(x1,y1,z1);
			}
			glEnd();
		}
		glLineWidth(1.0);
		if(Par.axok)
		{
		int i,intfv = (int)Par.fv;
		glBegin(GL_LINES);
		glColor3f (0.0, 1.0, Par.defaultz);
		glVertex3f(0.0,-(float)intfv,Par.defaultz);
		glVertex3f(0.0,(float)intfv,Par.defaultz);
		glVertex3f(-(float)intfv,0.0,Par.defaultz);
		glVertex3f((float)intfv,0.0,Par.defaultz);
		for(i=-intfv;i<intfv;i++)
		{
			glVertex3f(-0.1,(float)i,Par.defaultz);
			glVertex3f(0.1,(float)i,Par.defaultz);
			glVertex3f(-0.05,i+0.5,Par.defaultz);
			glVertex3f(0.05,i+0.5,Par.defaultz);
			glVertex3f((float)i,-0.1,Par.defaultz);
			glVertex3f((float)i,0.1,Par.defaultz);
			glVertex3f(i+0.5,-0.05,Par.defaultz);
			glVertex3f(i+0.5,0.05,Par.defaultz);
		}
		glEnd();
		}
		if(Par.gridok)
		{
		int i,intfv = (int)Par.fv;
		glBegin(GL_LINES);
		glColor3f (0.5, 0.5, 0.5);

		for(i=-intfv;i<intfv;i++)
		{
			glVertex3f(-(float)intfv,(float)i,Par.defaultz);
			glVertex3f((float)intfv,(float)i,Par.defaultz);
			glVertex3f((float)i,-(float)intfv,Par.defaultz);
			glVertex3f((float)i,(float)intfv,Par.defaultz);
		}
		glEnd();
		}
		if(Par.iok)
			Display_mesh2();
		}
   }
   glFlush();
	glPopMatrix();      // outer transform
#ifdef GLUT
   glutSwapBuffers();
#endif
   }
static void viewFrom()
{
     printf("Change view.  Look at the origin \n");
   printf("from the following coordinates: \n");
   scanf("%f %f %f", &Par.vX, &Par.vY, &Par.vZ);
   // force an update of gluLookAt(...) and draw
    resize(Par.thisWidth, Par.thisHeight);
   display();
}


   static void keyboard(unsigned char key,int x, int y)
   {
   if (key=='s')
	{
		//if((Par.ruppert.getNumberofSkynnyCells()==0)&&(Par.ruppert.getNumberOfViolatedEdges()==0))
		{

			/*Par.ruppert.projectVerticesOnSurface();
			Par.ruppert.findMedianLenghtEdge();
			//double d=(Par.ruppert.getGreaterLenghtEdge()-Par.ruppert.getSmallestLenghtEdge())*Par.reader.getNorma()*0.5;
			double d=Par.ruppert.getMedianLenghtEdge()*Par.reader.getNorma();
			sprintf(frase,"antsdev malha.vtk %lf output.poly",d*2.0);
			//Par.saida.write(Par.ruppert.getMesh(),"out.poly",Par.reader.getNorma());
			Par.vtkwriter.write(Par.ruppert.getMesh(),"malha.vtk",Par.reader.getNorma());
			system(frase);*/
		bool first =true;
		int k=0;
		while(k==0)
		{
			if (first)
				{

					Par.saida.write(Par.malha,"out.poly",1.0);
					//system("tetview out.poly");
					system("tetgen -pgqAC out.poly");
					system("tetview out.1.face");
					first=false;
				}
			else
				{
					Par.remesh.writeDeslocHeli("out","out.2.node");
					Par.remesh.execute("out","out.2.node");
					printf("Do you want execute again? 0=yes; 1=no\n");
					scanf("%d",&k);
				}
		}


		exit(1);
		}
		//else	exit(1);
	}
	if (key=='e')
	{
		Par.axok=!Par.axok;
	}
	if (key=='g')
	{
		Par.gridok=!Par.gridok;
	}
	if (key=='x')
	{

		Par.executed=true;
	}
	if (key=='p')
	{
		if(Par.cellok)
		{
			Par.ruppert.removeSkinnyCells(false);

		}
	}
	if (key=='t')
	{

		if(Par.cellok)
		{
			Par.ruppert.setStepok(false);
			Par.ruppert.removeSkinnyCells(true);
			//Par.ruppert.projectVerticesOnSurface();
		}

	}
	if(key=='i')
	{
		char frase[50];

		//Par.ruppert.projectVerticesOnSurface();
		Par.ruppert.findMedianLenghtEdge();

		double d=Par.ruppert.getMedianLenghtEdge()*Par.reader.getNorma();
		Par.vtkwriter.write(Par.ruppert.getMesh(),"malha.vtk",Par.reader.getNorma(), Par.ruppert.getNumberOfInsertedVertices());
		sprintf(frase,"ants malha.vtk %lf output.poly",d*1.0);


		system(frase);
		Par.remesh.readFromFile("OutputMesh.vtk");
		Par.malha=Par.remesh.getMesh();
		Par.remesh.findBoundaryVertices();
		Par.remeshok=true;
		Par.iok=!Par.iok;

		//Par.ruppert.insertBound();
		//Par.boundary_inserted=true;
	}
	if (key=='a')
	{
		Par.ruppert.setStepok(false);
		Par.ruppert.splitEncroachedSubsegments(false);
		if((Par.ruppert.getNumberOfViolatedEdges()==0)&&(Par.edgeok))
		{
			Par.ruppert.checkCells();

			Par.cellok=true;
		}
	}
// 	if (key=='w')
//
//
//
// 	{
//
//
//
// 		Par.mwriter.setIniV(Par.ruppert.getIniV());
//
//
//
// 		Par.mwriter.write(Par.ruppert.getMesh(),"mesh.dat",Par.reader.getNorma());
//
//
//
// 		Par.mwriter.writeQuad(Par.ruppert.getMesh(),"mesh_quad.dat",Par.reader.getNorma());
//
//
//
// 		exit(1);
//
//
//
// 	}
//
	if (key=='v')
	{

		Par.vtkwriter.write(Par.ruppert.getMesh(),"malha.vtk",Par.reader.getNorma(),Par.ruppert.getNumberOfInsertedVertices());
		exit(1);
	}
	if (key=='r')
	{

		Par.remesh.refine();
	}
	if(key==43)
	{
		Par.fact=Par.fact*2.0;
	}
	if(key==45)
	{
		Par.fact=Par.fact*0.5;
	}
	if(key==54)
	{
		Par.mX +=1.0*Par.fact;
	}
	if(key==52)
	{
		Par.mX +=-1.0*Par.fact;
	}
	if(key==56)
	{
		Par.mY +=1.0*Par.fact;
	}
	if(key==50)
	{
		Par.mY +=-1.0*Par.fact;
	}
	if(key==53)
	{
		Par.vZ+=-10.0*Par.fact;
		resize(Par.thisWidth,Par.thisHeight);
	}
	if(key==55)
	{
		Par.vZ+=10.0*Par.fact;
		resize(Par.thisWidth,Par.thisHeight);
	}
#ifdef GLUT
	glutPostRedisplay();
#endif
   }

   // callback, responds to mouse event
static void mouse(int button, int state, int x, int y) {
   switch (Par.mode) {
   case 1 : Par.mtX = x;
            Par.mtY = y;
            Par.mtZ = 0; break;
   case 2 : Par.rtX = x;
            Par.rtY = y; break;
   case 3 : Par.mtZ = y;
            Par.mtX = 0;
            Par.mtY = 0;
   }
}
// callback, responds to mouse motion
static void mouseDrag(int x, int y) {

   switch (Par.mode) {
   case 1 : Par.mX += (x - Par.mtX)*Par.fact; Par.mtX = x;
            Par.mY += (Par.mtY - y)*Par.fact; Par.mtY = y; break;
   case 2 : Par.rX += (x - Par.rtX); Par.rtX = x;
            Par.rY += (Par.rtY - y); Par.rtY = y; break;
   case 3 : Par.vZ+=(Par.mtZ-y); Par.mtZ=y;resize(Par.thisWidth,Par.thisHeight);//mZ += (mtZ - y); mtZ = y;
   }
#ifdef GLUT
   glutPostRedisplay();
#endif
}

static void menu(int item) {
   switch(item) {
   case 1 :
   case 2 :
   case 3 : Par.mode = item; printMode(); break;
   case 4 : viewFrom(); break;
   case 5 : Par.mX = 0; Par.mY = 0; Par.vZ = 20.0;
            Par.rX =0.0; Par.rY = 0.0;
            Par.mode = 0;  // no mode
            printMode(); break;
   case 6: Par.axok=!Par.axok; break;
   case 7: Par.gridok=!Par.gridok; break;
   case 8: exit(1);




   }
   resize(Par.thisWidth, Par.thisHeight);
#ifdef GLUT
            glutPostRedisplay();
#endif
}

};
template <class _Traits> ofMyVis<_Traits>::ofMyVis()
{
}
template <class _Traits> ofMyVis<_Traits>::ofMyVis(sMesh *_mesh,int d)
{
      Par.angleX = 0.0;
      Par.sizex=800;Par.sizey=600;Par.cont=0;
      Par.mode=0;
      Par.vX = 0.0, Par.vY = 0.0, Par.vZ = 20.0;   // eye coordinates
      Par.mX = 0, Par.mY = 0, Par.mZ = 0;              // model coordinates
      Par.mtX = 0, Par.mtY = 0, Par.mtZ = 0;           // temp model
      Par.rX = 0.0, Par.rY = 0.0;                // model rotations
      Par.rtX = 0.0, Par.rtY = 0.0;
      maxY=-100000000000.0;
      minY=100000000000.0;
      Par.malha=malha=_mesh;
	  Par.malha2=Par.remesh.getMesh();
      Par.pmaxY=malha->getMaxY();
      Par.pminY=malha->getMinY();
      Par.dim=d;
      Par.axok=false;
      Par.gridok=false;
      Par.defaultz=0.0;
	  Par.step=false;
	  Par.executed=true;
	  Par.fact=0.01;
	  Par.boundary_inserted=false;


	// insert your code here
}
template <class _Traits> ofMyVis<_Traits>::ofMyVis(char* filename,int d)
{
      Par.angleX = 0.0;
      Par.sizex=800;Par.sizey=600;Par.cont=0;
      Par.mode=0;
      Par.vX = 0.0, Par.vY = 0.0, Par.vZ = 20.0;   // eye coordinates
      Par.mX = 0, Par.mY = 0, Par.mZ = 0;              // model coordinates
      Par.mtX = 0, Par.mtY = 0, Par.mtZ = 0;           // temp model
      Par.rX = 0.0, Par.rY = 0.0;                // model rotations
      Par.rtX = 0.0, Par.rtY = 0.0;
      maxY=-100000000000.0;
      minY=100000000000.0;
	  Par.reader.read(filename);
      Par.edgeok=true;
	  Par.cellok=false;
      Par.dim=d;
      Par.axok=false;
      Par.gridok=false;
      Par.defaultz=0.0;
	  Par.step=true;
	  Par.boundary_inserted=false;
	  Par.fact=0.01;
	  Par.ruppert.preExecute(Par.reader.getLv(),Par.reader.getLids());
	  Par.ruppert.insertBoundBox(Par.reader.getLv());
	  Par.ruppert.insertVertex(Par.reader.getLv());
	  Par.ruppert.defineBoundaries();
	  Par.ruppert.removeExternal();
	  Par.ruppert.checkEdges(false);
	  Par.iok=false;
	  Par.remeshok=false;
	  Par.ref=new ofVector<ids,ids>(1000);
	  //Par.ruppert.execute(Par.reader.getLv(),Par.reader.getLids(),true);
	  Par.malha=malha=Par.ruppert.getMesh();
	  Par.remesh.setRuppert(&(Par.ruppert));
	  Par.malha2=Par.remesh.getMesh();
	  Par.malha3= new sMesh;
	  Par.executed=false;
	  Par.ruppert.setStepok(false);
		Par.ruppert.splitEncroachedSubsegments(false);
		if(Par.ruppert.getNumberOfViolatedEdges()==0)
		{
			Par.ruppert.checkCells();
			Par.edgeok=false;
			Par.cellok=true;
		}
		if((Par.cellok)&&(Par.malha->getNumberOfVertices()<100))
		{
			Par.ruppert.removeSkinnyCells(false);
		}
}
// class destructor
template <class _Traits> ofMyVis<_Traits>::~ofMyVis()
{
	// insert your code here
}
template <class _Traits> void ofMyVis<_Traits>::run(bool ok)
   {
 if(ok)
 {
#ifdef GLUT
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
   glutInitWindowSize (Par.sizex, Par.sizey);
   glutInitWindowPosition (0, 0);
   glutCreateWindow ("Solucao ");
	glutDisplayFunc(display);
   glutReshapeFunc(resize);
   glutMouseFunc(mouse);
   glutMotionFunc(mouseDrag);
   glutKeyboardFunc(keyboard);
   glutCreateMenu(menu);
   glutAttachMenu(GLUT_RIGHT_BUTTON);
   glutAddMenuEntry("Translate X Y", 1);
   glutAddMenuEntry("Rotate X Y", 2);
   glutAddMenuEntry("Zoom Z", 3);
   glutAddMenuEntry("View", 4);
   glutAddMenuEntry("Reset", 5);
   glutAddMenuEntry("Axes", 6);
   glutAddMenuEntry("Grid", 7);
   glutAddMenuEntry("Quit", 8);
   glutMainLoop();
#endif
 }
 else
 {
	 char frase[50];

		//Par.ruppert.projectVerticesOnSurface();
		Par.ruppert.findMedianLenghtEdge();

		double d=Par.ruppert.getMedianLenghtEdge()*Par.reader.getNorma();
		Par.vtkwriter.write(Par.ruppert.getMesh(),"malha.vtk",Par.reader.getNorma(), Par.ruppert.getNumberOfInsertedVertices());
		sprintf(frase,"ants malha.vtk %lf output.poly",d*0.5);


		system(frase);
		Par.remesh.readFromFile("OutputMesh.vtk");
		Par.malha=Par.remesh.getMesh();

		Par.remeshok=true;
		Par.iok=!Par.iok;

		Par.saida.write(Par.malha,"out.poly",1.0);

			system("tetgen -pgqAC out.poly");
			system("tetview out.1.face");
		//exit(1);
 }
    }
#undef SPACE5
   }

#else

xxxxx

#endif // OFMYVIS_H
